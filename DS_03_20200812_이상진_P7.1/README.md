
1. 과제설명
완전 이진 트리가 주어졌을 때, 다음과 같은 함수를 구현해보자.

i 번째 노드의 모든 조상노드를 출력하는 함
void PrintAncestor(int* bTree, int size, int idx);

i 번째 노드의 모든 왼쪽 후손 노드들을 출력하는 함수
void PrintLeftDescendant(int* bTree, int size, int idx);

i 번째 노드의 모든 오른쪽 후손 노드들을 출력하는 함수
void PrintRightDescendant(int* bTree, int size, int idx);

해당 값을 가진 노드의 인덱스를 반환하는 함수
int FindNode(int* bTree, int size, int data);

2. 소스코드
첨부

3. 고찰
 트리 라는 자료구조를 처음 생각 해봤을때 말단 노드에만 정보를 저장하는 형식을 잠깐 생각 하였으나 실제는 이와 다르게 돌아간다는 것을 일단 알게 되었다. 또한 스킬 트리 같은 예를 통해서 트리를 조금 더 잘 이해할 수 있었다. 트리라는 자료구조는 어떻게 보면 배열의 업그레이드된 버전으로 생각되기도 한다. 배열과은 순서를 통해 우선순위를 나누고 트리는 레벨을 통해 우선순위를 나눌 수 있다. 트리는 동레벨을 같이 취급하는게 쉽지만 배열은 이런것이 어렵다는 점에서 차이점을 생각 할 수 있다.
 아직 실무에서 사용한 경험이 없어 더 많은 장점이 생각나지는 않지만 이런 기본적인 형태만으로도 유용성이 높다는것은 확연히 느껴진다.
